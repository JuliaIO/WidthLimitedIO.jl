var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = WidthLimitedIO","category":"page"},{"location":"#WidthLimitedIO","page":"Home","title":"WidthLimitedIO","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for WidthLimitedIO.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [WidthLimitedIO]","category":"page"},{"location":"#WidthLimitedIO.IncrementalANSIEscape","page":"Home","title":"WidthLimitedIO.IncrementalANSIEscape","text":"IncrementalANSIEscape\n\nAn @enum collection encoding previously-received escape codes. Their primary purpose is to decide whether we are done rendering the escape code.\n\nSee ansi_esc_status for usage details.\n\n\n\n\n\n","category":"type"},{"location":"#Base.closewrite-Tuple{TextWidthLimiter}","page":"Home","title":"Base.closewrite","text":"closewrite(limiter::TextWidthLimiter)\n\nTurn off further writing to limiter. In many cases, iswritable(limiter) will now return false, but it is not an error to attempt to write further values to limiter.\n\nOne exception is if ANSI terminal escape codes (e.g., to change text color) had been previously written to limiter; in that case iswritable(limiter) will still return true, but henceforth the only characters written to limiter will be further escape codes. This will ensure, e.g., that text color gets reset to its original state.\n\nThus, it's acceptable to check iswritable(limiter) and skip further writing if the return value is false.\n\n\n\n\n\n","category":"method"},{"location":"#WidthLimitedIO.ansi_esc_status-Tuple{WidthLimitedIO.IncrementalANSIEscape, Char}","page":"Home","title":"WidthLimitedIO.ansi_esc_status","text":"ansi_esc_status(status::IncrementalANSIEscape, c::Char) → status\nansi_esc_status(c::Char) → status\n\nReturn a status code indicating our position within an ANSI terminal escape code.\n\nExamples\n\njulia> status = ansi_esc_status('m')   # ordinary character with no prior `status`\nNONE::IncrementalANSIEscape = 0\n\njulia> status = ansi_esc_status(status, '\u001b')  # start an escape sequence\nESCAPE1::IncrementalANSIEscape = 1\n\njulia> status = ansi_esc_status(status, '[')   # CSI\nESCAPE::IncrementalANSIEscape = 2\n\njulia> status = ansi_esc_status(status, '3')   # can be multiple digits\nPARAMETER::IncrementalANSIEscape = 5\n\njulia> status = ansi_esc_status(status, 'm')   # terminating final character\nFINAL::IncrementalANSIEscape = 6\n\njulia> status = ansi_esc_status(status, 'm')   # now 'm' is again an ordinary character\nNONE::IncrementalANSIEscape = 0\n\n\n\n\n\n","category":"method"}]
}
